git---
title: "CSS Project"
format: html
---

Loading packages

```{r}
library(tidyverse)
library(tidygraph)
library(igraph)
library(ggraph)
library(here)
library(ideanet)
```

Creating a network from an adjacency matrix of similarity scores

```{r}
#loading adjacency matrix of similarity scores
similarity_data <- read.csv(here("Code/professor_similarity_matrix.csv"), row.names = 1)

#creating adjacency matrix
adjacency_matrix <- as.matrix(similarity_data)

#removing self-loops
diag(adjacency_matrix) <- 0

isSymmetric(adjacency_matrix)

#Creating network
network <- graph_from_adjacency_matrix(adjacency_matrix, weighted = TRUE, mode = "undirected")
```

Adding traits to the nodes

```{r}
# discipline <- c("Law", "Economics", "Journalism and Public Policy", "Medicine", "Radiology", "Medicine", "Medicine", 
#                 "Obstetrics and Gynecology", "Anesthesiology", "Anesthesiology", "Neurosurgery", "Nursing","Urology",
#                 "Neurology",  "Surgery", "Head and Neck Surgery and Communication Sciences", "Anesthesiology", 
#                 "Medicine", "Pathology", "Art and Art History", "Orthopaedic Surgery")
# names <- V(network)$name
# rank <- rep(c("assistant", "associate", "professor"), 7)

people_traits <- data.frame(names = names, discipline = discipline, ranking = rank)

V(network)$discipline <- people_traits$discipline
V(network)$rank <- people_traits$ranking
V(network)$name
```

Weights

```{r}
#checking weights
E(network)$weight

#setting proximity threshold (based on sum of edge density over number of edges, so mean density)
proximity_threshold <- (sum(E(network)$weight)/ecount(network))
  
#modifying the network to only have ties above the mean
network_modified <- delete_edges(network, E(network)[weight < proximity_threshold])

E(network_modified)$weight
gsize(network_modified)

#checking degrees
degree(network_modified)

#check the given connections of a researcher X
neighbors(network_modified, v = "bill.adair")
```

Clustering

```{r}
partitions <- get_partitions(network_modified)

#needs to be assigned to the same object as the partitions object
partitions <- CHAMP(network_modified, partitions)

partitions <- get_CHAMP_map(network_modified, partitions)

#set resolution manually based on partitions object
network_clusters <- cluster_louvain(network_modified, resolution = 0.63) 

#assigning membership based on clusters
V(network_modified)$community <- membership(network_clusters)
```

Filter method

```{r}
#turning the network into a tibble
network_graph <- as_tbl_graph(network_modified)

#creating an edge only network
edges_network <- network_graph %>% 
  activate(edges) %>% 
  as_tibble()

#creating a node only network
nodes_network <- network_graph %>% 
  activate(nodes) %>% 
  as_tibble()

#combining the node information into the edge network
matching_tibble <- edges_network %>% 
  left_join(nodes_network %>% 
              mutate(from = row_number()), by = "from") %>% 
  left_join(nodes_network %>% 
              mutate(to = row_number()), by = "to") %>% 
  rename_with(\(x) gsub("\\.x", "_from", x)) %>% 
  rename_with(\(x) gsub("\\.y", "_to", x))

#filtering out any edges that are in the same community, discipline, or have previously collaborated
matching_test <- matching_tibble %>% 
  filter(community_from != community_to) %>% 
  filter(discipline_from != discipline_to)

matching_list <- matching_test %>% 
  group_by(name_from) %>% 
  arrange(desc(weight)) %>% 
  summarize(neighbors = list(name_to))

top_match <- matching_list %>% 
  

print(matching_list$neighbors)
?arrange
?map_first
?anti_join
?rowwise
```



```{r}
#preliminary visualization
ggraph(network_modified, layout = "fr") +
  geom_edge_link(alpha = 0.5) +
  geom_node_point(aes(color = as.factor(community)), size = 3)

plot(network_clusters, network_modified)
```



Paths or walks (of length 2)

```{r}
nodes <- V(network_modified)$name

all_paths <- list()

for (node in nodes) {
  paths <- all_simple_paths(network_modified, node, cutoff = 2)
  end_nodes <- character(0)
  for (path in paths) {
    path_names <- V(network_modified)$name[as.numeric(path)]
    end_nodes <- c(end_nodes, tail(path_names, 1))
    end_nodes <- unique(end_nodes)
    }
  all_paths[[node]] <- end_nodes
}
```

Once this list of end nodes is created, need to decide what the optimal collaboration threshold of similarity is
- Is path length of 2 best?
- What should the collaboration threshold be? It should be under the similarity threshold but over another amount. - Is the edge matching threshold too low?

```{r}
?contract
?simplify
```


